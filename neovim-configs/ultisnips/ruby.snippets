snippet _cb_spec_describe "simple rspec describe block"
describe "blah" do 
	it 'some true condition' do
		expect(true).to match(true)	
	end
end
endsnippet


snippet _cb_init "initialize"
#!/usr/bin/env ruby

require 'pp'

x=3

pp x
endsnippet


snippet _cb_input "take input"
input = gets.chomp
# put input
endsnippet

snippet  _if "If loop"
if ${1:a} == ${2:b}

elsif ${3:c%4} == 0

else

end
endsnippet


snippet _do "Do block"
	do |${1}|


end	
endsnippet 

snippet _cb_readfile "Read file line by line"
File.readlines('${1:filename}').each do |line|
	puts line
end
endsnippet


snippet _func "Function"
def ${1:blah}(${2})

end
endsnippet

snippet _cb_recursivehash "Recursive hash"
class RecursiveHash < Hash
def initialize
	recurse_hash = proc { |h, k| h[k] = Hash.new(&recurse_hash) }
		super(&recurse_hash)
	end
end
endsnippet


snippet _r_named_var "regex named variable"
r = %r{
\$
(?<dollars>\d+)
\.
(?<cents>\d+)
}x

pp r.match("$10.40")
endsnippet

snippet _r_backtrack "regex backtracking"
## positive lookahead
r = %r{
(\d)
(?=(\d{3})+$)
}x
pp "10000000000".gsub(r,'\1,')
# Above will give me  10,000,000,000

## positive look behind
pp /(?<=(\d_))\w+/.match("1234_AOB")
# Above will match text string only if digit followed by underscore
endsnippet 


snippet _loop_while "While loop"

i = 0
num = 5

# Condition first
while i < num  do
   puts "Inside the loop i = #{i}"
   i +=1
end


# Condition after first execution
begin
   puts("Inside the loop i = #{i}" )
   i +=1
end while i < num

endsnippet



snippet _cb_rescue "Rescue and Retry block"

(1..100).to_a.each   do |n|

  begin
    retry_cnt ||= 0

    num = n / rand(0..2)


  rescue  => e
    puts e.message   # equivalent of puts $!
    puts e.backtrace # equivalent of puts $@
    puts e.class     # print a class which is ZeroDivisionError

    # Following will allow max 3 divide by zero error
    if  retry_cnt < 3
      retry_cnt += 1
      retry
    else
      break
    end


  # this gets executed if no exceptions occurs
  else
    puts num

  # ensure block for begin
  ensure
    puts "Ensuring for begin block"
  end

# ensure block for the loop
ensure 
  puts "print wihtout rescue #{n}"
end	

endsnippet 

snippet _case "Case statement"

capacity = 50

case capacity
when 0
  pp "You ran out of gas."
when 1..20
  pp "The tank is almost empty. Quickly, find a gas station!"
when 21..70
  pp "You should be ok for now."
when 71..100
  pp "The tank is almost full."
else
  raise "Error: capacity has an invalid value (#{capacity})"
end

endsnippet


snippet _cb_blocks "various blocks"

## Yield block with an argument
def one_two_three
  yield 1
  yield 2
  yield 3
end

one_two_three { |number| puts number * 10 }
# 10, 20, 30

## Check for code block before calling yield
def do_something_with_block
  return "No block given" unless block_given?
  yield
end

## Explicit call for code block 
def explicit_block(&block)
  block.call # same as yield
end

explicit_block { puts "Explicit block called" }

## Lambda with an argument
times_two = ->(x) { x * 2 }
puts times_two.call(10)

## Lambda complains about wrong number of arguments
begin
puts times_two.call
rescue => e
  puts e.message
end

## Proc which does not care about arguments
t = Proc.new { |x,y| puts "Proc don't care about arguments!" }
t.call


# return value of Lambda vs Proc
# Should work
my_lambda = -> { return 1 }
puts "Lambda result: #{my_lambda.call}"
# Should raise exception
begin 
my_proc = Proc.new { puts "I am executing proc, but it will not see return value"; return 1 }
puts "Proc result: #{my_proc.call}"
rescue => e
  puts e.message 
end

# how procs and lambdas are different:
# Procs return from the current method, while lambdas return from the lambda itself.
# Procs donâ€™t care about the correct number of arguments, while lambdas will raise an exception.

endsnippet
